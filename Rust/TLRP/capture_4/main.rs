// 1. Перемещение владения (Move)

// 1.1: Перемещение при присваивании:

fn main() {
    let s1 = String::from("hello");
    // Создаём объект `String` в куче (heap).
    // Переменная `s1` владеет этими данными.

    let s2 = s1;

    // println!("{}", s1);
    // ^ Ошибка: `s1` больше не валидна после перемещения.

    println!("{}", s2);
    // OK: выводим "hello" через `s2`, владелец строки теперь именно `s2`.
}

// Что происходит:
// - При присвоении `s2 = s1` у типа String данные "переезжают" к `s2`.
// - То есть копируются только указатель, длина и емкость, но НЕ байты из кучи.
// - `s1` теперь невалидна, т.к. больше не владеет этими данными.
// - Rust делает это, чтобы избежать двойного освобождения памяти.


// 1.2: clone() — полное копирование:

fn main() {
    let s1 = String::from("hello");
    // Создаём объект `String` в куче, `s1` владеет "hello".

    let s2 = s1.clone();

    println!("s1 = {}, s2 = {}", s1, s2);
    // Обе переменные валидны, вывод: "s1 = hello, s2 = hello".
}

// Что происходит:
// - clone() — более затратная операция, так как копируются все байты из кучи.
// - В итоге у `s1` и `s2` разные участки памяти (разные адреса в куче).
// - Каждая переменная будет освобождать свой участок памяти по отдельности.



// 2. Владение и функции

fn main() {
    let s = String::from("hello");
    // `s` владеет строкой "hello".

    takes_ownership(s);
    // Что происходит:
    // - При передаче `s` в функцию `takes_ownership` владение переходит внутрь функции.
    // - После вызова `s` больше нельзя использовать, оно "перемещено".

    // println!("{}", s); // Ошибка: `s` уже перемещено во `takes_ownership`.

    let x = 5;
    // `x` — i32 (тип Copy).

    makes_copy(x);
    // Что происходит:
    // - i32 реализует Copy, значит значение `x` копируется побитово.
    // - `x` остаётся валидным, т.к. здесь нет перемещения.

    println!("x всё ещё доступен: {}", x);
    // Вывод: "5", `x` не утратил валидности.

    let s2 = gives_ownership();
    // Что происходит:
    // - Функция `gives_ownership` создаёт новую String и возвращает её.
    // - Теперь `s2` владеет этой новой строкой.

    println!("s2 приняла владение: {}", s2);

    let s3 = String::from("hi");
    // `s3` владеет "hi".

    let s4 = takes_and_gives_back(s3);
    // Что происходит:
    // - Функция принимает владение `s3`, а затем возвращает новый String.
    // - Возвращённая строка присваивается `s4`, теперь `s4` владеет данными.
    // - `s3` больше недоступна.

    println!("s4 = {}", s4);
}

fn takes_ownership(text: String) {
    // Что происходит:
    // - Параметр `text` получил владение. 
    // - По окончании функции `text` выходит из области видимости и освобождает память.
    println!("Внутри функции takes_ownership: {}", text);
}

fn makes_copy(num: i32) {
    // num — копия x, т.к. i32 — Copy.
    println!("Внутри функции makes_copy: {}", num);
    // num выйдет из области видимости, но это всего лишь скопированное целое число.
}

fn gives_ownership() -> String {
    // Создаём новую строку и возвращаем её.
    // Возвращение передаёт владение вызывающему коду.
    String::from("world")
}

fn takes_and_gives_back(a_string: String) -> String {
    // Что происходит:
    // - a_string владеет данными, полученными от `s3`.
    // - Мы возвращаем строку, передавая владение обратно.
    a_string
}




// 3. Ссылки и заимствование (Borrowing)

// 3.1: Неизменяемые ссылки:

fn main() {
    let s1 = String::from("hello");
    // `s1` владеет строкой.

    let len = calculate_length(&s1);

    println!("Длина строки '{}' равна {}", s1, len);
    // `s1` всё ещё доступна и не была перемещена.
}

fn calculate_length(s: &String) -> usize {
    // s — ссылка (reference) на String, она не владеет данными.
    // По окончании функции эта ссылка исчезнет, 
    // но исходная строка останется у её владельца (main).
    s.len()
}
// Что происходит:
// - Передаём ссылку &s1. Владение не перемещается, лишь "заимствуется".
// - Функция получает доступ только для чтения.


// 3.2: Изменяемые ссылки:

fn main() {
    let mut s = String::from("hello");
    // `s` — изменяемая переменная.

    change(&mut s);
    // - Передаём изменяемую ссылку (mutable reference) на `s`.
    // - Функция может модифицировать строку, не забирая владение.

    println!("Изменённая строка: {}", s);
}

fn change(some_string: &mut String) {
    // some_string — изменяемая ссылка на данные.
    some_string.push_str(", world");
    // - Фактически мы меняем исходный объект, на который ссылаемся,
    //   добавляя ", world" к строке.
}
// Правило безопасности Rust: в рамках одной области видимости может быть либо любая совокупность неизменяемых ссылок,
// либо только одна изменяемая ссылка (но не одновременно). Это предотвращает гонки данных.



// 4. Срезы (Slices)

// 4.1: Срез строки
fn main() {
    let s = String::from("Hello world");
    // `s` владеет "Hello world" в куче.

    let hello = &s[0..5];
    // - Создаём срез: ссылка на диапазон [0..5] (символы "Hello").
    // - Это не новая строка, а "указатель" на часть s.

    let world = &s[6..11];
    // Срез от индекса 6 включительно до 11 (не включая 11) -> "world".

    println!("'{}' и '{}'", hello, world);
    // Вывод: "Hello" и "world".
}


// 4.2: Функция, возвращающая первое словоПример: Функция, возвращающая первое слово

fn main() {
    let phrase = String::from("hello world");
    let word = first_word(&phrase);
    // - first_word возвращает срез &str.
    // - Этот срез "указывает" на байты в `phrase`.

    println!("Первое слово: {}", word); // "hello"

    // phrase.clear();
    // ^ Если раскомментировать, `phrase` станет пустой строкой.
    //   Срез `word` указывает на старые данные, значит они уже недействительны.
    //   Rust не даст нам использовать `word` после clear(), 
    //   предотвращая "висячие" ссылки.
}

fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();
    // Превращаем String в массив байтов.

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            // Что происходит:
            // - Нашли индекс пробела, возвращаем срез от 0 до i.
            return &s[0..i];
        }
    }

    // Если пробел не найден, возвращаем весь срез строки.
    &s[..]
}

