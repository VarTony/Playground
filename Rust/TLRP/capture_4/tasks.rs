// Упражнения по 4й главе.



// Задание 1. Перемещение и владение

// Создайте переменную типа String и присвойте ей какое-нибудь строковое значение.
// Создайте вторую переменную и переместите (move) в неё значение из первой переменной.
// Попытайтесь вывести значение первой переменной после перемещения.
// Убедитесь, что компилятор выдаёт ошибку. Закомментируйте «проблемную» строку, чтобы код скомпилировался.
// Добавьте вывод второй переменной (которой перешло владение).
// Цель: Понять, как «перемещение» (move) отбирает владение у исходной переменной и почему она перестаёт быть валидной.

fn task_1() {
    let str = String::from("Hello");
    let str_2 = str;

    // println!("{}, World!", str); value borrowed here after move
    println!("{}, World!", str_2);
}



// Задание 2. Copy-тип и не-Copy-тип

// Создайте две переменные:
// x типа i32 (число),
// s типа String.
// Напишите функцию, которая принимает на вход параметр типа i32. Передайте ей x и выведите x после вызова функции.
// Напишите аналогичную функцию, которая принимает параметр типа String. Передайте ей s и попробуйте вывести s после вызова.
// Объясните в комментариях, почему в первом случае всё работает, а во втором — нет.
// Цель: Отследить различие между типами, имеющими Copy, и теми, у которых отсутствует Copy.
fn task_2() {
    let func_int = |x: i32| println!("i32: {}", x);
    let func_str = |s: String| println!("String: {}", s);

    let x = 5;
    let s = String::from("str");

    func_int(x);
    func_str(s);

    println!("\nx: {}", x);
    // println!("s: {}", s); value borrowed here after move
}



// Задание 3. Ссылки и заимствование

// Создайте функцию calculate_length, которая принимает неизменяемую ссылку на String и возвращает её длину (usize).
// В main объявите изменяемую переменную String, но внутри саму строку менять не нужно.
// Передайте ссылку на строку в calculate_length, а затем выведите в main исходную строку и результат вычисления длины.
// Убедитесь, что всё скомпилируется и работает.
// Попробуйте изменить функцию так, чтобы она принимала изменяемую ссылку (и что-нибудь меняла в строке). Посмотрите, какие ошибки (если будут) выдаст компилятор, и при необходимости скорректируйте код.
// Цель: Отработать навык передачи ссылок (borrow) — неизменяемых и изменяемых — и понять разницу в ограничениях.
fn task_3() {
    let mut s = String::from("Text");

    let calculate_length = |s: &mut String| -> usize {
        s.push_str("!");
        s.len()
    };

    let r1 = calculate_length(&mut s);
    
    println!("{} length: {}", s, r1);
}



// Задание 4. Конфликт изменяемых ссылок

// Создайте в main изменяемую переменную типа String.
// Объявите две одновременные изменяемые ссылки на неё (например, let r1 = &mut s; let r2 = &mut s;).
// Попробуйте что-нибудь вывести с помощью обеих ссылок.
// Убедитесь, что компилятор ругается на нарушение правила «только одна изменяемая ссылка в области видимости».
// Поправьте код так, чтобы ошибка исчезла (обычно достаточно использовать одну ссылку, или ограничить время жизни одной ссылки, прежде чем объявлять вторую).
// Цель: Увидеть на практике, как Rust предотвращает гонки данных, не позволяя иметь несколько активных изменяемых ссылок на один и тот же объект одновременно.
fn task_4() {
    let mut s = String::from("Text");

    // let r0 = &s;  -- immutable borrow occurs here
    let r1 = &mut s;
    // let r2 = &mut s; second mutable borrow occurs here

    println!("r1: {}", r1);
    // println!("r0: {}, r1: {:?}", r0, r1);
    // println!("r1: {}, r2: {:?}", r1, r2); 
}


// Задание 5. Функция «первое слово» со срезами

// Реализуйте функцию first_word, которая принимает ссылку на String и возвращает срез (&str) первого слова.
// В main создайте строку, содержащую несколько слов, и выведите результат работы first_word.
// Попробуйте потом изменить (через метод clear() или push_str()) саму строку после того, как получили срез. Посмотрите, пропустит ли компилятор такой код.
// Поэкспериментируйте: сохраните результат работы first_word в переменную, а затем измените исходную строку. Убедитесь, что Rust не позволяет использовать «висячие» срезы.
fn task_5() {
    let s = String::from("Hello, text!");

    fn first_word(s: &str) -> &str {
        let bytes = s.as_bytes();
        for (i, &item) in bytes.iter().enumerate() {
            if item == b' ' {
                return &s[0..i];
            }
        }
        &s[..]
    };

    let r = first_word(&s[..]);

    println!("{} world!", r);

    // s.clear();
    // ^ cannot borrow as mutable
}

    
    
fn main() {
    task_1();
    task_2();
    task_3();
    task_4();
    task_5();
}
