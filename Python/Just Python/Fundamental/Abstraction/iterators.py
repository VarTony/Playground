from typing import Callable, Iterable

# Реализация собственного цикла for на основе итератора и замыкания (первое приближение).
# 
# В Python работа цикла for и других конструкций, которые перебирают элементы,
# основана на протоколе итерации.
#
# __iter__()  — "магический метод" (специальный метод), который должен возвращать сам итератор.
#               Его вызывает Python, когда объект попадает в контекст перебора (например, в for).
#
# __next__()  — "магический метод", который возвращает следующий элемент последовательности.
#               Вызывается неявно на каждой итерации цикла. 
#               Если элементы закончились, метод обязан выбросить исключение StopIteration,
#               чтобы Python понял, что перебор завершён.
#
# Они называются "магическими", потому что не вызываются напрямую пользователем —
# их активирует сам интерпретатор, когда мы используем привычный синтаксис (for, list(), tuple() и т.д.).
#
# Замыкание в примере будет использоваться для сохранения состояния между вызовами __next__,
# что позволит имитировать работу встроенных итерируемых объектов.

def naive_for_loop(apply_func: Callable, sequence: Iterable):
    iterator = sequence.__iter__()
    def loop_step():
        try:
            apply_func(iterator.__next__())
            return loop_step()
        except StopIteration:
            print('Конец перебора')

    return loop_step()


naive_for_loop(print, {'a': 'a', 'b': 2})
naive_for_loop(print, 'iterable')
naive_for_loop(print, [1, 2, 3, 4, 5])
naive_for_loop(print, range(3, 11))

