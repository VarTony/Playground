from typing import Callable, Iterable


# Класс Counter — пример собственного итератора.
# Итератор — это объект, который знает, как выдавать элементы по одному,
# запоминая своё текущее состояние между вызовами.
class Counter:
    def __init__(self, start, end):
        # Начальное значение счётчика
        self.cur = start
        # Конечное значение, до которого нужно досчитать
        self.end = end

    def __iter__(self):
        # __iter__() должен возвращать сам итератор.
        # В данном случае объект Counter является и итерируемым, и итератором одновременно.
        return self

    def __next__(self):
        # __next__() возвращает следующий элемент последовательности
        # или возбуждает StopIteration, если элементов больше нет.
        if self.cur > self.end:
            raise StopIteration
        # Возвращаем текущее значение и переходим к следующему
        self.cur += 1
        return self.cur - 1


# Генераторная функция my_generator — пример "генератора".
# Она принимает на вход любой итерируемый объект (в том числе итератор).
def my_generator(it):
    # Перебираем элементы из переданного источника
    for value in it:
        # Возвращаем наружу квадрат текущего числа.
        # После yield выполнение генератора "замораживается" до следующего запроса.
        yield value ** 2


# Создаём экземпляр итератора, который выдаёт числа от 1 до 5
counter = Counter(1, 5)

# Передаём этот итератор в генератор, который возводит числа в квадрат
gen = my_generator(counter)

# Превращаем генератор в список и выводим результат
# При этом генератор будет исчерпан: пройтись повторно уже нельзя.
print(list(gen))  # [1, 4, 9, 16, 25]




# Использование генератора или объекта range с большим диапазоном выгоднее,
# чем создание списка всех чисел сразу, потому что в памяти хранится
# только текущее состояние итерации, а не весь набор значений.
#
# В Python 3 range() возвращает "ленивый" (iterable) объект, который
# вычисляет элементы на лету по формуле, а не хранит их в массиве.
# Это позволяет работать с очень большими диапазонами, не занимая много памяти.
#
# Пример: range(1_000_000_000) занимает константное количество памяти (~48 байт),
# в то время как list(range(...)) потребует гигабайты
#
# Однако, в отличие от списка, генератор:
#   - Не поддерживает случайный доступ по индексу (нельзя обратиться к my_generator[100]),
#     т.к. для получения элемента нужно пройти всю последовательность от начала.
#   - Может быть пройден только один раз — после окончания итерации он "исчерпан".
#
# Список же хранит все элементы в памяти, но позволяет за O(1) получать доступ
# к любому элементу по индексу и многократно перебирать данные.

# my_list = [x**2 for x in range(1_000_000_000)]

my_generator = (x**2 for x in range(1_000_000_000))




# Реализация собственного цикла for на основе итератора и замыкания (первое приближение).
# 
# В Python работа цикла for и других конструкций, которые перебирают элементы,
# основана на протоколе итерации.
#
# __iter__()  — "магический метод" (специальный метод), который должен возвращать сам итератор.
#               Его вызывает Python, когда объект попадает в контекст перебора (например, в for).
#
# __next__()  — "магический метод", который возвращает следующий элемент последовательности.
#               Вызывается неявно на каждой итерации цикла. 
#               Если элементы закончились, метод обязан выбросить исключение StopIteration,
#               чтобы Python понял, что перебор завершён.
#
# Они называются "магическими", потому что не вызываются напрямую пользователем —
# их активирует сам интерпретатор, когда мы используем привычный синтаксис (for, list(), tuple() и т.д.).
#
# Замыкание в примере будет использоваться для сохранения состояния между вызовами __next__,
# что позволит имитировать работу встроенных итерируемых объектов.

def naive_for_loop(apply_func: Callable, sequence: Iterable):
    iterator = sequence.__iter__()
    def loop_step():
        try:
            apply_func(iterator.__next__())
            return loop_step()
        except StopIteration:
            print('Конец перебора')

    return loop_step()


naive_for_loop(print, {'a': 'a', 'b': 2})
naive_for_loop(print, 'iterable')
naive_for_loop(print, [1, 2, 3, 4, 5])
naive_for_loop(print, range(3, 11))

