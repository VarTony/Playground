Все разбираемые здесь паттерн и не только, как правило являются мультипарадигменными ответами на   устоявшиеся проблемы. В данном случае реализация построена на основе структурного подхода - ООП, однако все это можно реализовать и через иные подходы написания программ. <br/> 
Паттерны, как сказано выше, в общем, не связаны с понятием ООП, но именно в ООП их любят структурировать и описывать. Поэтому эта тема особенно распространена в языках с классовой структурой, например Java, C# или PHP. И большинство этих паттернов сводится к тому, как правильно применять полиморфизм подтипов в разных ситуациях. Вот только некоторые из широко известных, которые опираются на полиморфизм: <br/> 
 • Адаптер <br/> 
 • Стратегия <br/> 
 • Абстрактная фабрика <br/> 
 • Мост <br/> 
 • Композит <br/> 
 • Декоратор <br/> 
 • Посредник <br/> 
 • Цепочка ответственности <br/> 
 • Наблюдатель <br/> 
 • Состояние <br/> 
 • Шаблонный метод <br/> 
 • Посетитель <br/> 
 Некоторые из них связаны с абстракцией и имеют внутреннее состояние, другие — обычные функции, упакованные в классы только ради полиморфизма (но могли бы быть реализованы и обычными функциями, которые диспетчеризуются разными способами). <br/> 

 Большая часть паттернов, которая связана с полиморфизмом, строится по одному и тому же принципу. Зная его, можно самостоятельно принимать правильные решения, даже не зная про паттерн для данной ситуации. Ключевая идея состоит в том, что берется все множество вариантов поведения и на каждый создается свой собственный класс.<br/> 
 Например, в Стратегии количество классов-стратегий совпадает с количеством разных способов вычисления. Если их будет пять, то придется создать пять классов. По крайней мере в классовых языках. В языках, где предпочитают функции, будет создано пять разных функций и это все равно будет Стратегия.