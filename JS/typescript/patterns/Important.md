Все разбираемые здесь паттерн и не только, как правило являются мультипардигмеными ответами на   устоявшиеся проблемы. В данном случае реализация построена на основе структурно ООП подхода, однако 
все это можно реализовать и через иные подходы написания программ. 
Паттерны, как сказано выше, в общем, не связаны с понятием ООП, но именно в ООП их любят структурировать и описывать. Поэтому эта тема особенно распространена в языках с классовой структурой, например Java, C# или PHP. И большинство этих паттернов сводится к тому, как правильно применять полиморфизм подтипов в разных ситуациях. Вот только некоторые из широко известных, которые опираются на полиморфизм:
 • Адаптер
 • Стратегия
 • Абстрактная фабрика
 • Мост
 • Композит
 • Декоратор
 • Посредник
 • Цепочка ответственности
 • Наблюдатель
 • Состояние
 • Шаблонный метод
 • Посетитель
 Некоторые из них связаны с абстракцией и имеют внутреннее состояние, другие — обычные функции, упакованные в классы только ради полиморфизма (но могли бы быть реализованы и обычными функциями, которые диспетчеризуются разными способами).

 Большая часть паттернов, которая связана с полиморфизмом, строится по одному и тому же принципу. Зная его, можно самостоятельно принимать правильные решения, даже не зная про паттерн для данной ситуации. Ключевая идея состоит в том, что берется все множество вариантов поведения и на каждый создается свой собственный класс.
 Например, в Стратегии количество классов-стратегий совпадает с количеством разных способов вычисления. Если их будет пять, то придется создать пять классов. По крайней мере в классовых языках. В языках, где предпочитают функции, будет создано пять разных функций и это все равно будет Стратегия.